####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
from queue import PriorityQueue
import json

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        # addr là Router hiện tại
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE 
        self.heartbeat_time = heartbeat_time # khoảng thời gian giữa các lần gửi gói tin
        self.last_time = 0 # thời gian gửi gói tin gần nhất
        # TODO
        # add your own class fields and initialization code here
        self.forwarding_table = {} # {dst: current port to neighbor} bảng định tuyến, cho biết để đi đến router bất kỳ thì cần đi qua các nút nào trước bằng port
        self.link_state = {self.addr: {}}  # {router: {neighbor: cost}} mỗi router sẽ chứa thông tin về chi phí để đi đến neghbors hoặc chính nó
        self.sequence_number = 0 # đại diện cho sự đổi về lượng liên kết giữa router hiện tại và các node khác (thêm hoặc xóa liên kết thì đều + 1)
        self.seq_db = {self.addr: 0} # {router: seq_num} lưu thông tin về sequence_number với các node khác của router hiện tại
        self.neighbors = {}  # {router: (port, cost)} lưu thông tin về các router hàng xóm
        pass 

    def handle_packet(self, port, packet):
        # port là chỉ số cổng
        # packet là thông tin của gói
        """Process incoming packet."""
        # TODO 
        if packet.is_traceroute:
            """ là tập tin bình thường chỉ chứa dữ liệu để gửi từ client đến client khác
                router sẽ không xử lý gói tin này mà chỉ gửi đến router hàng xóm dựa trên bảng định tuyến để truyền đến client cuối
            """
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            
            if packet.dst_addr in self.forwarding_table: # nếu gói tin có địa chỉ đích trong bảng định tuyến
                self.send(self.forwarding_table[packet.dst_addr], packet)
            pass
        else:
            """ là tập tin chứa thông tin của các route khác 
                router chỉ được gửi giữa các router với nhau để cập nhật thông tin định tuyến
                => hay nói cách khác tập tin này là 1 yêu cầu thêm liên kết giữa 2 router với nhau
            """
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
           
            content = json.loads(packet.content)
            src = content["src"]
            seq = content["seq"]
            links = content["links"]

            # Nếu thông tin mới
            if src not in self.seq_db or seq > self.seq_db[src]:
                self.seq_db[src] = seq
                self.link_state[src] = links
                self._update_forwarding_table()
                # Gửi gói tin đến các hàng xóm khác
                for rtr, (pst, cst) in self.neighbors.items():
                    if pst != port:
                        pkt = Packet(Packet.ROUTING, self.addr, None, packet.content)
                        self.send(pst, pkt) # truyền gói tin mới(pkt) đến các hàng xóm khác bằng port (pst)
        pass

    def handle_new_link(self, port, endpoint, cost):
        """
        Handle new link. : Cập nhật lại các thông tin: forwarding_table neighbors, link_state, seq_db khi có sự thay đổi về link
        + port: cổng kết nối
        + endpoint: router hàng xóm
        + cost: chi phí kết nối"""
        # TODO
        # update local data structures and forwarding table
        # broadcast the new link state of this router to all neighbors
        self.neighbors[endpoint] = (port, cost) # thêm thông tin hàng xóm của rounter hiện tại
        self.link_state[self.addr][endpoint] = cost # Lưu riêng chi phí từ router hiện tại đến hàng xóm
        self.sequence_number += 1 # tăng sequence_number lên 1 để tránh trùng lăp và phản ánh sự thay đổi của sequence_number
        self.seq_db[self.addr] = self.sequence_number
        self._update_forwarding_table() # cập nhật bảng định tuyến
        
        # Gửi gói tin đến các hàng xóm khác
        pkt = Packet(Packet.ROUTING, self.addr, None, json.dumps({ # None vì thay vì phải viết tất cả các neighbors rất phức tạp thì ta gửi nó thông qua port đến neighbors bằng send
            "src": self.addr,
            "seq": self.sequence_number,
            "links": self.link_state[self.addr]
        }))
        for rtr, (pst, cst) in self.neighbors.items():
            self.send(pst, pkt) # gửi gói tin router hiện tại đến neighbors thông qua port p
        pass

    def handle_remove_link(self, port):
        """
        Handle removed link. : Cập nhật lại các thông tin: forwarding_table neighbors, link_state, seq_db khi có sự thay đổi về link
        + port: cổng kết nối đến router hàng xóm của router hiện tại
        """
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        endpoint = None
        for ep, (p, _) in self.neighbors.items(): # duyệt qua các neighbor
            if p == port: # nếu cổng neighbor bằng cổng hiện tại
                endpoint = ep # lưu lại neighbor
                break
        if endpoint:
            del self.neighbors[endpoint]
            if endpoint in self.link_state[self.addr]:
                del self.link_state[self.addr][endpoint]
            self.sequence_number += 1
            self.seq_db[self.addr] = self.sequence_number
            self._update_forwarding_table() # cập nhật bảng định tuyến

            # Gửi gói tin đến các hàng xóm khác
            pkt = Packet(Packet.ROUTING, self.addr, None, json.dumps({
                "src": self.addr,
                "seq": self.sequence_number,
                "links": self.link_state[self.addr]
            }))
            for rtr, (pst, cst) in self.neighbors.items():
                self.send(pst, pkt) # gửi gói tin router hiện tại đến neighbors thông qua port p
        pass


    def _update_forwarding_table(self):
        # Thuật toán Dijkstra
        # Khởi tạo các cấu trúc dữ liệu
        dist = {self.addr: 0}  # chứa chi phí thấp nhất từ router hiện tại đến các router khác
        prev = {}  # Node trước đó trên đường đi ngắn nhất
        pq = PriorityQueue() # chứa các chi phí và router chưa được duyệt
        visited = set() # chứa các router/node đã được duyệt

        pq.put((0, self.addr)) # thêm router hiện tại vào hàng đợi với chi phí 0

        # Thuật toán Dijkstra
        while not pq.empty():
            cost, curr = pq.get() # lấy router/node có chi phí thấp nhất chưa được duyệt
            if curr in visited:
                continue                
            visited.add(curr)
            # Duyệt qua các hàng xóm của router hiện tại
            for neighbor, weight in self.link_state.get(curr, {}).items():   
                if neighbor not in visited:
                    new_cost = cost + weight
                    if neighbor not in dist or new_cost < dist[neighbor]:# nếu neighbor chưa được duyệt hoặc chi phí mới thấp hơn chi phí cũ
                        dist[neighbor] = new_cost
                        prev[neighbor] = curr
                        pq.put((new_cost, neighbor)) 
        # Xây dựng bảng chuyển tiếp
        self.forwarding_table = {}
        for destination in dist: # kiểm tra tất cả các router đích trong dist xem có kết nối (xuất phát) từ src tới không
            if destination == self.addr:
                continue
            # Tìm next hop đầu tiên trên đường đi tới đích
            next_hop = destination
            while prev.get(next_hop) != self.addr:
                if prev.get(next_hop) is None:
                    break
                next_hop = prev[next_hop]
            # Thêm vào bảng chuyển tiếp nếu có đường đi
            if next_hop in self.neighbors:
                port = self.neighbors[next_hop][0]
                self.forwarding_table[destination] = port # port là cổng để đi đến neighbor có lối đi đến dst ngắn nhất
        print(f"Router {self.addr} Forwarding table: {self.forwarding_table}") # in bảng định tuyến
        print(f"seq_db: {self.seq_db}") # in seq_db
        pass

    def handle_time(self, time_ms):
        """
        Handle current time. : Thực hiện gửi định kỳ gói tin đến các router hàng xóm dùng có thay đổi hay không
        + time_ms: thời gian hiện tại
        """
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            
            # Gửi gói tin đến các hàng xóm khác
            pkt = Packet(Packet.ROUTING, self.addr, None, json.dumps({
            "src": self.addr,
            "seq": self.sequence_number,
            "links": self.link_state[self.addr]
            }))
            for rtr, (pst, cst) in self.neighbors.items():
                self.send(pst, pkt)
        pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
